:mod:`trieste.utils`
====================

.. py:module:: trieste.utils

.. autoapi-nested-parse::

   This package contains library utilities. 



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   objectives/index.rst


Package Contents
----------------

.. class:: Err(exc: Exception)


   Bases: :class:`Result[NoReturn]`

   Wraps the exception that occurred during a failed evaluation. 

   :param exc: The exception that occurred.

   .. method:: is_ok(self) -> bool
      :property:

      `False` always. 


   .. method:: unwrap(self) -> NoReturn

      :raise Exception: Always. Raises the wrapped exception.



.. class:: Ok(value: T_co)


   Bases: :class:`Result[T_co]`

   Wraps the result of a successful evaluation. 

   :param value: The result of a successful evaluation.

   .. method:: is_ok(self) -> bool
      :property:

      `True` always. 


   .. method:: unwrap(self) -> T_co

      :return: The wrapped value.



.. class:: Result

   Bases: :class:`Generic[T_co]`, :class:`abc.ABC`

   Represents the result of an operation that can fail with an exception. It contains either the
   operation return value (in an :class:`Ok`), or the exception raised (in an :class:`Err`).

   To check whether instances such as

       >>> res = Ok(1)
       >>> other_res = Err(ValueError("whoops"))

   contain a value, use :attr:`is_ok` (or :attr:`is_err`)

       >>> res.is_ok
       True
       >>> other_res.is_ok
       False

   We can access the value if it :attr:`is_ok` using :meth:`unwrap`.

       >>> res.unwrap()
       1

   Trying to access the value of a failed :class:`Result`, or :class:`Err`, will raise the wrapped
   exception

       >>> other_res.unwrap()
       Traceback (most recent call last):
           ...
       ValueError: whoops

   **Note:** This class is not intended to be subclassed other than by :class:`Ok` and
   :class:`Err`.

   .. method:: is_ok(self) -> bool
      :property:

      `True` if this :class:`Result` contains a value, else `False`. 


   .. method:: is_err(self) -> bool
      :property:

      `True` if this :class:`Result` contains an error, else `False`. The opposite of
      :attr:`is_ok`.


   .. method:: unwrap(self) -> T_co
      :abstractmethod:

      :return: The contained value, if it exists.
      :raise Exception: If there is no contained value.



.. data:: T_co
   

   An unbounded covariant type variable. 


.. function:: jit(apply: bool = True, **optimize_kwargs) -> Callable[([C], C)]

   A decorator that conditionally wraps a function with `tf.function`.

   :param apply: If `True`, the decorator is equivalent to `tf.function`. If `False`, the decorator
       does nothing.
   :param optimize_kwargs: Additional arguments to `tf.function`.
   :return: The decorator.


.. function:: shapes_equal(this: trieste.type.TensorType, that: trieste.type.TensorType) -> trieste.type.TensorType

   Return a scalar tensor containing: `True` if ``this`` and ``that`` have equal runtime shapes,
   else `False`.


.. function:: to_numpy(t: trieste.type.TensorType) -> numpy.ndarray

   :param t: An array-like object.
   :return: ``t`` as a NumPy array.


.. class:: DEFAULTS

   Default constants used in Trieste. 

   .. attribute:: JITTER
      :annotation: :Final[float] = 1e-06

      The default jitter, typically used to stabilise computations near singular points, such as in
      Cholesky decomposition.



